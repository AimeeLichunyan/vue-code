{"version":3,"file":"vue.js","sources":["../../src/observer/array.js","../../src/observer/index.js","../../src/state.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 拿到数组原型的方法（或者拿到数组原来的方法）\nlet oldArrayProtoMethods = Array.prototype;\n\n// 继承原来数组的方法 arrayMethods.__proto__ = oldArrayProtoMethods,继承以后可以重写，如果没有重写，则会顺着原型链找到原来数组的方法\nexport let arrayMethods = Object.create(oldArrayProtoMethods)\nlet methods = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'splice'\n]\n// 这是个高阶函数或者叫切片编程\nmethods.forEach(method => {\n    arrayMethods[method] = function(...args) { // this就是ob\n        const result = oldArrayProtoMethods[method].apply(this,arguments)\n        let inserted;\n        let ob = this.__ob__\n        switch (method) {\n            case 'push': // arr.push({a:1},{b:2})\n            case 'unshift': // push和unshift方法都是追加的,追加的内容可能是对象类型，应该再次进行劫持\n                inserted = args\n                break;\n            case 'splice': // vue.$set实现的原理就是splice，删除，添加，修改\n            inserted = args.slice(2) // arr.splice(0,1,{a:1})\n            default:\n                break;\n        }\n        if(inserted) ob.observeArray(inserted) // 给数组新增的值进行观测\n        return result\n    }\n})","import { arrayMethods } from \"./array\";\n\n// 数据观测的方法\nclass Observer {\n  constructor(value) {\n    // 使用defineProperty重新定义属性，\n    // 判断一个对象是否被观测过，看它有没有__ob__这个属性\n    Object.defineProperty(value,'__ob__',{\n      enumerable:false, // 不能被，枚举，不能被循环出来\n      configurable:false,\n      value: this\n    })\n    // 判断是否是数组\n    if(Array.isArray(value)) {\n      // 调用push，shift，unshift,splice,sort,reverse,pop等操作\n      // 函数劫持，或者切片编程\n      value.__proto__ = arrayMethods\n      // 观测数组中的对象类型，对象变化触发一些操作\n      this.observeArray(value)\n    }else {\n      //   使用defineProperty 重新定义属性\n    this.walk(value);\n    }\n    \n  }\n  observeArray(value) {\n    value.forEach(item => {\n      observe(item)\n    })\n  }\n  walk(data) {\n    let keys = Object.keys(data);\n    keys.forEach((key) => {\n      defineReactive(data, key, data[key]); // Vue.utils.defineReactive\n    });\n  }\n}\nfunction defineReactive(data, key, value) {// 为每一个对象添加defineProperty，getset函数，进行数据劫持\n  observe(value) // 递归进行检测，value是否是对象，只要对象层级比较深，就会不停的递归，影响性能，所以在vue3中使用proxy实现，vue3是懒递归\n  Object.defineProperty(data, key, { // 其实是一个闭包，当前作用域下data不销毁\n    get() {\n      return value;\n    },\n    set(newValue) {\n      console.log('设置')\n      if (newValue == value) return; // 如果新值和老值一样则不赋值操作\n      observe(newValue) // 判断设置的新的值是不是对象，如果用户将值改为对象，则继续监控\n      value = newValue;\n    },\n  });\n}\nexport default function observe(data) {\n  if (typeof data !== \"object\" || data === null) {\n    return data;\n  }\n  if(data.__ob__) {\n    return data;\n  }\n  return new Observer(data);\n}\n","import observe from \"./observer/index.js\";\n\n// 状态的初始化;\nexport function initSate(vm) {\n  // vue初始化的顺序就是：先初始化属性，在是方法，再是data\n  const opts = vm.$options;\n  if (opts.props) {\n    initProps(vm);\n  }\n  if (opts.methods) {\n    initMethods(vm);\n  }\n  //   核心部分\n  if (opts.data) {\n    initData(vm);\n  }\n  if (opts.computed) {\n    initComputed(vm);\n  }\n  if (opts.watch) {\n    initWatch(vm);\n  }\n}\nfunction initProps() {}\nfunction initMethods() {}\n\nfunction initData(vm) {\n  let data = vm.$options.data;\n  vm._data = data = typeof data == \"function\" ? data.call(vm) : data;\n  //   数据的劫持方案： 对象object.defineProperty\n  // 数组会单独处理\n  observe(data);\n}\nfunction initComputed() {}\nfunction initWatch() {}\n","import { initSate } from \"./state\";\n\nexport function initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this;\n    vm.$options = options;\n\n    // 初始化状态（数据做初始化劫持，改变数据时应该更新视图）\n    //  vue 组件中很多状态，data,props,watch,computed\n    initSate(vm);\n\n    // vue核心特性：响应式数据原理\n    // Vue 是什么框架，MVVM（不完全是）怎么是？ 数据变化视图会更新，视图变化数据会被影响，\n    // 怎么不是？ mvvm不能跳过数据直接更新视图，但是vue有$ref可以直接操作dom\n  };\n}\n","import { initMixin } from \"./init\";\nfunction Vue(options) {\n  console.log(options);\n  this._init(options);\n}\n//写成一个个的插件进行扩展，解耦方法\n// vue初始化方法\ninitMixin(Vue);\nexport default Vue;\n"],"names":["oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","args","result","apply","arguments","inserted","ob","__ob__","slice","observeArray","Observer","value","defineProperty","enumerable","configurable","isArray","__proto__","walk","item","observe","data","keys","key","defineReactive","get","set","newValue","console","log","initSate","vm","opts","$options","props","initData","computed","watch","_data","call","initMixin","Vue","_init","options"],"mappings":"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"}